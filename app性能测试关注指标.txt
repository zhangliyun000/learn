APP性能测试关注指标
目标
  - 掌握App的运行时的资源消耗情况，作为准出标准，并为性能优化提供依据
  - 在具体的资源方面，重点考虑以下情形
  - 判断是否发生内存泄漏
  - 判断是否存在明显卡顿
  - 判断相比上一版本，内存、CPU、FPS指标是否发生劣化
测评指标 
Android 
目前Android提供了3个大项CPU、卡顿和内存的指标，后续将增加功耗、流量以及IO等。
CPU
针对CPU资源，我们提供了3项子指标
CPU使用率指标说明
整机CPU使用率：用于衡量设备的负载情况。数值越大，表明当前手机任务越繁忙。
`计算原理：`
CPU执行时间片 = `A时刻的CPU（总时间片 - Idle状态时间片） - B时刻的CPU（总时间片 - Idle状态时间片）`
总时间片 = `A 时刻的CPU总时间片 - B时刻的CPU总时间片`
CPU使用率 = CPU执行时间片/总时间片

`CPU的时间片可以通过  cat /proc/stat获取`

App CPU使用率：用于衡量App对CPU的使用情况。
计算原理和计算方式和系统CPU使用率计算相似，使用制定进程的时间片，cat /proc/pid/stat
规范化使用率：这里我们参考了腾讯的指标设计，增加了这一指标。即考虑到手机cpu频率是变化的，用传统cpu使用率计算方法，在低频率时刻计算出cpu使用率=30%，和在cpu高频时刻计算出cpu使用率=30%。同样都是30%但性能消耗显然后者更高。
计算原理：
规范化使用率 = 上述计算的CPU使用率 * (当前所有CPU频率之和/所有CPU频率最大值之和)

所以，我们一共提供了4个CPU使用率来衡量CPU的消耗，推荐使用规范化的App CPU使用率来作为应用的测评标准。
CPU核使用率指标说明
类似于CPU使用率，这里增加了分别对每一个核的计算。可以综合考量当前CPU的调度和使用情况。
CPU频率指标
提供每个核的频率变化曲线，可以用来考量CPU的调度情况。
FPS
针对流畅性，我们一共提供了8个参考指标。
<!--br {mso-data-placement:same-cell;}--> td {white-space:pre-wrap;border:1px solid #dee0e3;}指标解释FPS数据获取时间周期内，实际渲染帧数/ 数据获取间隔时间。Jank单帧绘制耗时> MOVIE_FRAME_TIME 时，计一次jank。BigJank单帧绘制耗时> 3 * MOVIE_FRAME_TIME 时，计一次big jank。Stutter卡顿比。当发生jank的帧的累计时长与区间时长的比值。
其中，MOVIE_FRAME_TIME即一帧电影的耗时，一般电影是24帧每秒，所以
MOVIE_FRAME_TIME = 1000 / 24

简单情况下，推荐使用FPS来衡量页面综合流畅度，重点关注BigJank的发生场景。
内存
针对内存我们提供了2项不同层面的指标。
从系统角度看App（进程）的内存占用：
<!--br {mso-data-placement:same-cell;}--> td {white-space:pre-wrap;border:1px solid #dee0e3;}指标说明PSSProportional Set Size 实际使用的物理内存（按比例分配共享库占用的内存）即进程实际占有内存（不含分配但未使用的内存）+按比例分配的共享库内存。VmSize虚拟内存大小。32位CPU架构可使用的地址空间大小为2^32=4GB，其中高位部分为内核空间。一个32位的应用，它基于32位的zygote fork得来，Linux进程在fork时会继承父进程所有虚拟地址空间，因此在一个应用出生时，它的虚拟内存空间基本就在1.8G以上32位应用 + 32位设备: 内核空间占用1G地址空间，应用可用虚拟地址上限为3G - 1.8G = 1.2G32位应用 + 64位设备: 内核运行在64位，应用可用虚拟地址上限为4G - 1.8G = 2.2G64位CPU + 64位应用基本可以认为虚拟空间是足够的。但我们仍然要关注不合理占用。
当App发生非Java OOM的时候，大部分是因为虚拟内存不足，所以，我们推荐重点关注VmSize的增长情况。
从虚拟机角度看内存的分布：
<!--br {mso-data-placement:same-cell;}--> td {white-space:pre-wrap;border:1px solid #dee0e3;}指标名说明Java从 Java 或 Kotlin 代码分配的对象的内存。由于Java堆之外的内存分配与Java分配绑定。应用程序将调用Android框架，Android框架调用Native库，并且内存分配。它们的生命周期将与Java对象相关联。优化 Java Heap 上的对象，也有助于其它类型内存的回收。NativeNatie Heap（从 C 或 C++ 代码分配的对象内存。即使应用中不使用 C++，也可能会看到此处使用的一些原生内存，因为 Android 框架使用原生内存代表处理各种任务，如处理图像资源和其他图形时。Stack测评结果里很多时候显示为0，是因为小于1M。Graphic指图形缓冲区队列向屏幕显示像素（包括 GL 表面、GL 纹理等等）所使用的内存。Codedex jar so ttf 等文件占用的内存System系统代码占用的内存
功耗
设备电流(功率=电流*电压，设备电压恒定)可以用来衡量整机的功耗情况。当我们只保留我们待测应用处于前台运行，且尽可能关闭其他应用时，可以用整机的功耗来衡量待测应用的功耗。这就是我们功耗测评的基本背景。

iOS #
CPU使用率：App、整机
FPS：fps、jank、bigJank、jankTime，stutter
Memory内存：Footprint、VirtualSize、ResidentSize
GPU：device、renderer、tiler
Net：down、up
IO：read、write
CPU使用率
使用率=总CPU使用率(Xcode中展示的使用率)/核心数
  - TotalCPU： 表示整机CPU使用率
  - ProcessCPU： 表示进程CPU使用率
FPS
1秒内应用界面真实平均刷新次数，俗称帧率/FPS
  - FPS Avg： 平均帧率(一段时间内平均FPS)
  - Jank
    - 当前帧耗时>两帧电影帧耗时(1000ms/24*2=84ms)。
  - BigJank
    - 当前帧耗时>三帧电影帧耗时(1000ms/24*3=125ms)。
  - Stutter
指定时间内卡顿的时长占比，Stutter(卡顿率) = ∑Jank time / Time，Jank为卡顿次数，Stutter为卡顿率，Jank和Stutter趋势有一致性，但并非完全线性，因为每次Jank卡顿严重性是不一样的。同时也说明了，没有Jank卡顿出现，自然也就卡顿率是0了。
Memory
  - FootPrint：应用实际使用的物理内存（包含压缩内存的实际大小），OOM与FootPrint有关，常看的Memory指标（与PerfDog中Memory对应）http://www.samirchen.com/ios-app-memory-usage/
  - Virtual Memory ： （64位CPU的最大寻址空间为2的64次方bytes，计算后其可寻址空间达到了惊人的16TB（treabytes），即16384GB）
  - Real Memory： 实际物理内存占用，既Instruments中Resident Memory Size。注：物理内存系统策略有关，衡量内存指标时不会关注，但是它有助于分析定位整体性能问题。比如：footprint没有降低，说明应用没有释放内存，但是real memory却降低了，说明系统对内存做了压缩。由于压缩会占用CPU资源，同时相应会导致FPS降低
GPU
  - Render： 渲染器利用率(像素着色处理阶段，若占比高，说明是PS阶段出现瓶颈，shader过于复杂或纹理大小、采样复杂等)
  - Tiler： Tiler利用率(顶点着色处理阶段，若占比高，说明是VS阶段出现瓶颈，顶点数太多等原因)
  - Device： 设备利用率(整体GPU利用率)
Network
  - up： 上行流量
  - down： 下行流量
I/O
  - read： 读取
  - write： 写入
Battery Power - 功耗（仅wifi连接可用）
  - 电流： 当前电池电流的绝对值，单位-mA
  - 电量： 当前电池电量，单位-%
  - 电压： 当前电池电压，单位-V
  - 温度： 当前电池温度，单位-摄氏度
测评指标标准 
不同业务类型、不同场景下，资源使用差别较大，并非要追求资源消耗的绝对的低值，需要和业务需求、用户体验间综合衡量，建立业务指标和性能指标的关联关系，然后选择合适的指标和标准进行控制和优化。同时，一般情况下，还需要针对高中低三档机型进行分别设置。
举个栗子，低端机上同样的代码性能较差，在无损降级取得一定收益后，我们发现已经无法取得相对大盘更大的收益，通过AB实验，我们发现一定的有损降级，比如去掉某些动画，能带来更好的点击率的数据，进而我们通过反复调整降级点，在线下取得更好的性能指标，最终在线上也带来了显著的播放时长收益。最终，我们确立了低端机下后续的性能标准。
这里提供一般的指标确立思路：
- 当前版本指标定为标准，新版本保证不劣化（或者在一定范围内，比如启动耗时增加少于5毫秒）
- 针对显著影响直观感受的先确定明确的卡口标准。比如Feed流的滑动卡顿对用户体验有明显的损失，方便确定中档机型FPS均值不低于58，持续滑动1分钟卡顿次数少于2次。
- 尝试一定的劣化实验验证预期收益。比如AB实验发现启动增加10%，用户留存明显降低，我们就基本可以确定，如果我们能优化启动10%，那么能给留存率带来接近的提升。那么指标标准就应该进行提高。
